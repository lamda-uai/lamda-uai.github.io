'use strict'

<<<<<<< HEAD
const BB = require('bluebird')

=======
const util = require('util')

const fs = require('fs')
const fsm = require('fs-minipass')
const ssri = require('ssri')
>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
const contentPath = require('./path')
const figgyPudding = require('figgy-pudding')
const fs = require('graceful-fs')
const PassThrough = require('stream').PassThrough
const pipe = BB.promisify(require('mississippi').pipe)
const ssri = require('ssri')
const Y = require('../util/y.js')

const lstatAsync = BB.promisify(fs.lstat)
const readFileAsync = BB.promisify(fs.readFile)

const ReadOpts = figgyPudding({
  size: {}
})

const lstat = util.promisify(fs.lstat)
const readFile = util.promisify(fs.readFile)

module.exports = read
<<<<<<< HEAD
function read (cache, integrity, opts) {
  opts = ReadOpts(opts)
  return withContentSri(cache, integrity, (cpath, sri) => {
    return readFileAsync(cpath, null).then(data => {
      if (typeof opts.size === 'number' && opts.size !== data.length) {
        throw sizeError(opts.size, data.length)
      } else if (ssri.checkData(data, sri)) {
        return data
      } else {
        throw integrityError(sri, cpath)
      }
=======

const MAX_SINGLE_READ_SIZE = 64 * 1024 * 1024
function read (cache, integrity, opts = {}) {
  const { size } = opts
  return withContentSri(cache, integrity, (cpath, sri) => {
    // get size
    return lstat(cpath).then(stat => ({ stat, cpath, sri }))
  }).then(({ stat, cpath, sri }) => {
    if (typeof size === 'number' && stat.size !== size)
      throw sizeError(size, stat.size)

    if (stat.size > MAX_SINGLE_READ_SIZE)
      return readPipeline(cpath, stat.size, sri, new Pipeline()).concat()

    return readFile(cpath, null).then((data) => {
      if (!ssri.checkData(data, sri))
        throw integrityError(sri, cpath)

      return data
>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
    })
  })
}

module.exports.sync = readSync
function readSync (cache, integrity, opts) {
  opts = ReadOpts(opts)
  return withContentSriSync(cache, integrity, (cpath, sri) => {
    const data = fs.readFileSync(cpath)
    if (typeof opts.size === 'number' && opts.size !== data.length) {
      throw sizeError(opts.size, data.length)
    } else if (ssri.checkData(data, sri)) {
      return data
    } else {
      throw integrityError(sri, cpath)
    }
  })
}

module.exports.sync = readSync

function readSync (cache, integrity, opts = {}) {
  const { size } = opts
  return withContentSriSync(cache, integrity, (cpath, sri) => {
    const data = fs.readFileSync(cpath)
    if (typeof size === 'number' && size !== data.length)
      throw sizeError(size, data.length)

    if (ssri.checkData(data, sri))
      return data

    throw integrityError(sri, cpath)
  })
}

module.exports.stream = readStream
module.exports.readStream = readStream
<<<<<<< HEAD
function readStream (cache, integrity, opts) {
  opts = ReadOpts(opts)
  const stream = new PassThrough()
  withContentSri(cache, integrity, (cpath, sri) => {
    return lstatAsync(cpath).then(stat => ({ cpath, sri, stat }))
  }).then(({ cpath, sri, stat }) => {
    return pipe(
      fs.createReadStream(cpath),
      ssri.integrityStream({
        integrity: sri,
        size: opts.size
      }),
      stream
    )
  }).catch(err => {
    stream.emit('error', err)
  })
  return stream
}

let copyFileAsync
if (fs.copyFile) {
  module.exports.copy = copy
  module.exports.copy.sync = copySync
  copyFileAsync = BB.promisify(fs.copyFile)
=======

function readStream (cache, integrity, opts = {}) {
  const { size } = opts
  const stream = new Pipeline()
  withContentSri(cache, integrity, (cpath, sri) => {
    // just lstat to ensure it exists
    return lstat(cpath).then((stat) => ({ stat, cpath, sri }))
  }).then(({ stat, cpath, sri }) => {
    if (typeof size === 'number' && size !== stat.size)
      return stream.emit('error', sizeError(size, stat.size))

    readPipeline(cpath, stat.size, sri, stream)
  }, er => stream.emit('error', er))

  return stream
}

let copyFile
if (fs.copyFile) {
  module.exports.copy = copy
  module.exports.copy.sync = copySync
  copyFile = util.promisify(fs.copyFile)
>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
}

function copy (cache, integrity, dest, opts) {
  opts = ReadOpts(opts)
  return withContentSri(cache, integrity, (cpath, sri) => {
<<<<<<< HEAD
    return copyFileAsync(cpath, dest)
  })
}

function copySync (cache, integrity, dest, opts) {
  opts = ReadOpts(opts)
=======
    return copyFile(cpath, dest)
  })
}

function copySync (cache, integrity, dest) {
>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
  return withContentSriSync(cache, integrity, (cpath, sri) => {
    return fs.copyFileSync(cpath, dest)
  })
}

module.exports.hasContent = hasContent
<<<<<<< HEAD
function hasContent (cache, integrity) {
  if (!integrity) { return BB.resolve(false) }
  return withContentSri(cache, integrity, (cpath, sri) => {
    return lstatAsync(cpath).then(stat => ({ size: stat.size, sri, stat }))
  }).catch(err => {
    if (err.code === 'ENOENT') { return false }
    if (err.code === 'EPERM') {
      if (process.platform !== 'win32') {
=======

function hasContent (cache, integrity) {
  if (!integrity)
    return Promise.resolve(false)

  return withContentSri(cache, integrity, (cpath, sri) => {
    return lstat(cpath).then((stat) => ({ size: stat.size, sri, stat }))
  }).catch((err) => {
    if (err.code === 'ENOENT')
      return false

    if (err.code === 'EPERM') {
      /* istanbul ignore else */
      if (process.platform !== 'win32')
>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
        throw err
      else
        return false
    }
  })
}

module.exports.hasContent.sync = hasContentSync
<<<<<<< HEAD
function hasContentSync (cache, integrity) {
  if (!integrity) { return false }
=======

function hasContentSync (cache, integrity) {
  if (!integrity)
    return false

>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
  return withContentSriSync(cache, integrity, (cpath, sri) => {
    try {
      const stat = fs.lstatSync(cpath)
      return { size: stat.size, sri, stat }
    } catch (err) {
<<<<<<< HEAD
      if (err.code === 'ENOENT') { return false }
      if (err.code === 'EPERM') {
        if (process.platform !== 'win32') {
          throw err
        } else {
          return false
        }
=======
      if (err.code === 'ENOENT')
        return false

      if (err.code === 'EPERM') {
        /* istanbul ignore else */
        if (process.platform !== 'win32')
          throw err
        else
          return false
>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
      }
    }
  })
}

function withContentSri (cache, integrity, fn) {
<<<<<<< HEAD
  return BB.try(() => {
=======
  const tryFn = () => {
>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
    const sri = ssri.parse(integrity)
    // If `integrity` has multiple entries, pick the first digest
    // with available local data.
    const algo = sri.pickAlgorithm()
    const digests = sri[algo]
<<<<<<< HEAD
=======

>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
    if (digests.length <= 1) {
      const cpath = contentPath(cache, digests[0])
      return fn(cpath, digests[0])
    } else {
<<<<<<< HEAD
      return BB.any(sri[sri.pickAlgorithm()].map(meta => {
        return withContentSri(cache, meta, fn)
      }, { concurrency: 1 }))
        .catch(err => {
          if ([].some.call(err, e => e.code === 'ENOENT')) {
            throw Object.assign(
              new Error('No matching content found for ' + sri.toString()),
              { code: 'ENOENT' }
            )
          } else {
            throw err[0]
          }
        })
    }
=======
      // Can't use race here because a generic error can happen before
      // a ENOENT error, and can happen before a valid result
      return Promise
        .all(digests.map((meta) => {
          return withContentSri(cache, meta, fn)
            .catch((err) => {
              if (err.code === 'ENOENT') {
                return Object.assign(
                  new Error('No matching content found for ' + sri.toString()),
                  { code: 'ENOENT' }
                )
              }
              return err
            })
        }))
        .then((results) => {
          // Return the first non error if it is found
          const result = results.find((r) => !(r instanceof Error))
          if (result)
            return result

          // Throw the No matching content found error
          const enoentError = results.find((r) => r.code === 'ENOENT')
          if (enoentError)
            throw enoentError

          // Throw generic error
          throw results.find((r) => r instanceof Error)
        })
    }
  }

  return new Promise((resolve, reject) => {
    try {
      tryFn()
        .then(resolve)
        .catch(reject)
    } catch (err) {
      reject(err)
    }
>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
  })
}

function withContentSriSync (cache, integrity, fn) {
  const sri = ssri.parse(integrity)
  // If `integrity` has multiple entries, pick the first digest
  // with available local data.
  const algo = sri.pickAlgorithm()
  const digests = sri[algo]
  if (digests.length <= 1) {
    const cpath = contentPath(cache, digests[0])
    return fn(cpath, digests[0])
  } else {
    let lastErr = null
<<<<<<< HEAD
    for (const meta of sri[sri.pickAlgorithm()]) {
=======
    for (const meta of digests) {
>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
      try {
        return withContentSriSync(cache, meta, fn)
      } catch (err) {
        lastErr = err
      }
    }
<<<<<<< HEAD
    if (lastErr) { throw lastErr }
=======
    throw lastErr
>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
  }
}

function sizeError (expected, found) {
<<<<<<< HEAD
  var err = new Error(Y`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`)
=======
  const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`)
>>>>>>> 5c1ca5729ada370419ab8dfd3af061376cb0fa47
  err.expected = expected
  err.found = found
  err.code = 'EBADSIZE'
  return err
}

function integrityError (sri, path) {
  var err = new Error(Y`Integrity verification failed for ${sri} (${path})`)
  err.code = 'EINTEGRITY'
  err.sri = sri
  err.path = path
  return err
}
